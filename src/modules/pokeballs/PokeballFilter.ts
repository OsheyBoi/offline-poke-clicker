import { Observable, Unwrapped } from 'knockout';
import { Pokeball } from '../GameConstants';
import Setting from '../settings/Setting';
import { PokeballFilterMatchData, PokeballFilterOptions, pokeballFilterOptions } from './PokeballFilterOptions';

export type PokeballFilterParams = {
    name: string;
    options: PokeballFilterOptions;
    ball?: Pokeball;
    inverted?: boolean;
    enabled?: boolean;
};

export default class PokeballFilter {
    public ball: Observable<Pokeball>;
    public _options: Observable<{
        [K in keyof PokeballFilterOptions]:Setting<PokeballFilterOptions[K]>
    }>;
    public _name: Observable<string>;
    public enabled: Observable<boolean>;
    public inverted: Observable<boolean>;

    public uuid: string;

    constructor(
        name: string,
        options: PokeballFilterOptions,
        ball: Pokeball = Pokeball.None,
        enabled = true,
        inverted = false,
    ) {
        this._name = ko.observable(name);
        this.ball = ko.observable(ball);
        this._options = ko.observable(Object.fromEntries(
            Object.entries(options).map(
                ([k, v]) => [k, pokeballFilterOptions[k].createSetting(v)]),
        ));
        this.enabled = ko.observable(enabled);
        this.inverted = ko.observable(inverted);
        this.uuid = crypto.randomUUID?.() ?? // randomUUID is not available in insecure contexts or older browsers
            Array.prototype.slice.apply(crypto.getRandomValues(new Uint8Array(16))) // use getRandomValues to generate 16 bytes
                .map((i: number) => ('0' + i.toString(16)).slice(-2)).join('') // turn the bytes into their hexadecimal representation
                .replace(/^(.{8})(.{4})(.{4})(.{4})(.+)$/, '$1-$2-$3-$4-$5'); // format like a UUID generated by randomUUID
    }

    test(data: PokeballFilterMatchData): boolean {
        if (!this.enabled()) {
            return false;
        }

        return this.inverted()
            // true if any option doesn't match
            ? Object.entries(this.options).some(
                ([key, setting]) => !pokeballFilterOptions[key].matchTest(
                    setting.observableValue(),
                    data[key],
                ),
            )
            // true only when all options match
            : Object.entries(this.options).every(
                ([key, setting]) => pokeballFilterOptions[key].matchTest(
                    setting.observableValue(),
                    data[key],
                ),
            );
    }

    get name(): string {
        return this._name();
    }

    set name(value: string) {
        this._name(value);
    }

    get options(): Unwrapped<typeof this._options> {
        return this._options();
    }

    set options(value: Unwrapped<typeof this._options>) {
        this._options(value);
    }

    toJSON(): Required<PokeballFilterParams> {
        return {
            name: this.name,
            options: Object.fromEntries(
                Object.entries(this.options).map(([k, s]) => [k, s.observableValue()]),
            ),
            ball: this.ball(),
            inverted: this.inverted(),
            enabled: this.enabled(),
        };
    }

    static tooltipDescription = (
        data: PokeballFilter,
        translator: (key: string, namespace: string) => string,
    ): string => {
        let description = '';

        if (!data.enabled()) {
            description += translator('pokeball.tooltip.filters.disabled', 'modules');
            description += '<br/><br/>';
        }

        const options = Object.entries(data.options);
        if (!options.length) {
            description += translator('pokeball.tooltip.filters.all', 'modules');
            return description;
        }

        description += translator(
            data.inverted()
                ? 'pokeball.tooltip.filters.affectWithoutTraits'
                : 'pokeball.tooltip.filters.affectWithTraits',
            'modules',
        );

        description += '<ul class="pokeballFilterOptionDescriptions">';
        description += options
            .map(([opt, setting]) => {
                const value = setting.observableValue();

                const result = translator(
                    `pokeball.filters.${setting.name}.description${value === false ? '.negative' : ''}`,
                    'modules',
                );
                if (typeof value === 'boolean') {
                    return result;
                }

                let valueText = undefined;
                for (let index = 0; index < setting.options.length; ++index) {
                    if (setting.options[index].value === value) {
                        valueText = setting.options[index].text;
                        break;
                    }
                }
                if (!valueText) {
                    return result;
                }

                if (opt !== 'category') {
                    valueText = translator(`${opt}.${valueText.replace(/\s/g, '')}`, 'constants');
                }

                return  `${result} ${valueText}`;
            })
            .map((option) => `<li>${option}</li>`)
            .join('');
        description += '</ul>';

        return description;
    };
}
